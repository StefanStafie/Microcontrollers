/* Main.c file generated by New Project wizard
 *
 * Created:   Sun Jan 8 2023
 * Processor: PIC16F887
 * Compiler:  MPLAB XC8
 */

#define TEMP_95 49072
#define TEMP_90 32736
#define TEMP_85 16400

#define TIMR1_SPEED_10 9285
#define TIMR1_SPEED_20 37410

#include <xc.h>
#define _XTAL_FREQ 20000000

// default config
#pragma config FOSC = HS   // Oscillator Selection bits (HS oscillator)
#pragma config WDTE = OFF  // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE = OFF // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOREN = OFF // Brown-out Reset Enable bit (BOR disabled)
#pragma config LVP = OFF   // Low-Voltage (Single-Supply) In-Circuit Serial Programming Enable bit (RB3 is digital I/O, HV on MCLR must be used for programming)
#pragma config CPD = OFF   // Data EEPROM Memory Code Protection bit (Data EEPROM code protection off)
#pragma config WRT = OFF   // Flash Program Memory Write Enable bits (Write protection off; all program memory may be written to by EECON control)
#pragma config CP = OFF    // Flash Program Memory Code Protection bit (Code protection off)

unsigned char RA1_curent;
unsigned char RB0_old, RB1_old, RB2_old;
unsigned int selectedSpeed = TIMR1_SPEED_10;
unsigned long impulses; // the number of impulses that were received by sensor;
unsigned long time;     // miliseconds elapsed from PIC start
unsigned motorRunning = 0;

void init();
unsigned int analogRead();
unsigned int calculateCarSpeed();

void main(void)
{
    init();
    while (1)
    {
        RC0 = motorRunning;

        unsigned int termistorValue = analogRead();
        unsigned int carSpeed = calculateCarSpeed();

        if (termistorValue > TEMP_95)
        {
            motorRunning = 1;
        }

        if (termistorValue > TEMP_90)
        {

            if (carSpeed > 15)
            {
                motorRunning = 1;
            }
        }

        if (termistorValue < TEMP_85)
        {
            motorRunning = 0;
        }
    }
}

// 1km/h == 4000 impulsuri/h == 4000/3600000 impulsuri/ms == 0,00111111 impulsuri/ms
// speed = (impulsuri* 0,0011111)/timp == impulsuri/(timp * 900)
unsigned int calculateCarSpeed()
{
    double realSpeed = (double)impulses / ((double)time * (double)900);
    return (int)realSpeed;
}

void init()
{
    // input/output
    TRISA = 0x01;
    TRISB = 0x07;
    TRISC = 0;

    PORTC = 0;

    // analog read
    ADCON0 = 0b00000001; // Set RA0 as analog input;
    ADCON1 = 0b00000001; // All pins as Analog Input and setting Reference Voltages

    // timer
    T1CON = 0x31;          // Timer-1 with Prescaler 1:8
    TMR1 = TIMR1_SPEED_10; // viteza default 10 km/h
    GIE = 1;               // Enable Global Interrupt
    PEIE = 1;              // Enable the Peripheral Interrupt
    TMR1IF = 0;            // clear flag
    TMR1IE = 1;            // enable timer 1 interrupt
    TMR1ON = 1;            // Start Timer1

    // Interrupt on Change
    RBIE = 1;
    ANSELH = 0x00;
    WPUB = 0b00000111; // pt RB0,RB1,RB2
    IOCB = 0b00000111;
    RBIF = 0;
}

void interrupt handler()
{
    // timer interrupt
    if (TMR1IF == 1)
    {
        if (selectedSpeed == TIMR1_SPEED_10)
            time += 90;
        else
            time += 180;

        TMR1 = selectedSpeed;
        RA1_curent = !RA1_curent;
        RA1 = RA1_curent;

        TMR1IF = 0; // reset timer flag
    }

    // PORTB interrupt on change
    if (RBIF == 1)
    {
        if (RB0_old != RB0 && RB0 == 1)
        {
            // Button RB0 was pressed. Set speed to 10 km/h
            selectedSpeed = TIMR1_SPEED_10;
        }

        if (RB1_old != RB1 && RB1 == 1)
        {
            // Button RB1 was pressed. Set speed to 20 km/h
            selectedSpeed = TIMR1_SPEED_20;
        }

        if (RB2_old != RB2)
        {
            // received impulse from sensor
            impulses++;
        }

        RB0_old = RB0;
        RB1_old = RB1;
        RB2_old = RB2;

        RBIF = 0;
    }
}

unsigned int analogRead()
{
    ADCON0 &= 0xC5;
    __delay_ms(2); // Acquisition time to charge hold capacitor
    GO_nDONE = 1;  // Initializes A/D conversion
    while (GO_nDONE)
        ;                            // Waiting for conversion to complete
    return ((ADRESH << 8) + ADRESL); // Return result
}